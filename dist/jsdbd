#!/usr/bin/env node
"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var path=require("path"),os=require("os"),child_process=require("child_process"),http=require("http"),http__default=_interopDefault(http),EventEmitter=_interopDefault(require("events")),fs$1=_interopDefault(require("fs")),util=_interopDefault(require("util")),net=require("net");function toArr(e){return null==e?[]:Array.isArray(e)?e:[e]}function toVal(e,t,s,i){var n,r=e[t],o=~i.string.indexOf(t)?null==s||!0===s?"":String(s):"boolean"==typeof s?s:~i.boolean.indexOf(t)?"false"!==s&&("true"===s||(e._.push(0*(n=+s)==0?n:s),!!s)):0*(n=+s)==0?n:s;e[t]=null==r?o:Array.isArray(r)?r.concat(o):[r,o]}var lib=function(e,t){t=t||{};var s,i,n,r,o,a={_:[]},l=0,c=0,d=0,u=(e=e||[]).length;const h=void 0!==t.alias,p=void 0!==t.unknown,f=void 0!==t.default;if(t.alias=t.alias||{},t.string=toArr(t.string),t.boolean=toArr(t.boolean),h)for(s in t.alias)for(i=t.alias[s]=toArr(t.alias[s]),l=0;l<i.length;l++)(t.alias[i[l]]=i.concat(s)).splice(l,1);if(t.boolean.forEach(e=>{t.boolean=t.boolean.concat(t.alias[e]=t.alias[e]||[])}),t.string.forEach(e=>{t.string=t.string.concat(t.alias[e]=t.alias[e]||[])}),f)for(s in t.default)t.alias[s]=t.alias[s]||[],(t[typeof t.default[s]]||[]).push(s);const m=p?Object.keys(t.alias):[];for(l=0;l<u;l++){if("--"===(n=e[l])){a._=a._.concat(e.slice(++l));break}for(c=0;c<n.length&&45===n.charCodeAt(c);c++);if(0===c)a._.push(n);else if("no-"===n.substring(c,c+3)){if(r=n.substring(c+3),p&&!~m.indexOf(r))return t.unknown(n);a[r]=!1}else{for(d=c+1;d<n.length&&61!==n.charCodeAt(d);d++);for(r=n.substring(c,d),o=n.substring(++d)||l+1===u||45===(""+e[l+1]).charCodeAt(0)||e[++l],i=2===c?[r]:r,d=0;d<i.length;d++){if(r=i[d],p&&!~m.indexOf(r))return t.unknown("-".repeat(c)+r);toVal(a,r,d+1<i.length||o,t)}}}if(f)for(s in t.default)void 0===a[s]&&(a[s]=t.default[s]);if(h)for(s in a)for(i=t.alias[s]||[];i.length>0;)a[i.shift()]=a[s];return a};const GAP=4,__="  ",ALL="__all__",DEF="__default__",NL="\n";function format(e){if(!e.length)return"";let t=maxLen(e.map(e=>e[0]))+GAP;return e.map(e=>e[0]+" ".repeat(t-e[0].length)+e[1]+(null==e[2]?"":`  (default ${e[2]})`))}function maxLen(e){let t=0,s=0,i=0,n=e.length;if(n)for(;n--;)(s=e[n].length)>t&&(i=n,t=s);return e[i].length}function noop(e){return e}function section(e,t,s){if(!t||!t.length)return"";let i=0,n="";for(n+=NL+__+e;i<t.length;i++)n+=NL+__+__+s(t[i]);return n+NL}var help=function(e,t,s,i){let n="",r=t[s],o=`$ ${e}`,a=t[ALL],l=e=>`${o} ${e}`.replace(/\s+/g," "),c=[["-h, --help","Displays this message"]];if(s===DEF&&c.unshift(["-v, --version","Displays current version"]),r.options=(r.options||[]).concat(a.options,c),r.options.length>0&&(r.usage+=" [options]"),n+=section("Description",r.describe,noop),n+=section("Usage",[r.usage],l),!i&&s===DEF){let e=Object.keys(t).filter(e=>!/__/.test(e)),s=e.map(e=>[e,(t[e].describe||[""])[0]]);n+=section("Available Commands",format(s),noop),n+=NL+__+"For more info, run any command with the `--help` flag",e.slice(0,2).forEach(e=>{n+=NL+__+__+`${o} ${e} --help`}),n+=NL}return n+=section("Options",format(r.options),noop),n+=section("Examples",r.examples.map(l),noop)},error=function(e,t,s=1){let i=section("ERROR",[t],noop);i+=NL+__+`Run \`$ ${e} --help\` for more info.`+NL,console.error(i),process.exit(s)},parse=function(e){return(e||"").split(/^-{1,2}|,|\s+-{1,2}|\s+/).filter(Boolean)},sentences=function(e){return(e||"").replace(/([.?!])\s*(?=[A-Z])/g,"$1|").split("|")},utils={help:help,error:error,parse:parse,sentences:sentences};const ALL$1="__all__",DEF$1="__default__";class Sade{constructor(e,t){let[s,...i]=e.split(/\s+/);t=t||i.length>0,this.bin=s,this.ver="0.0.0",this.default="",this.tree={},this.command(ALL$1),this.command([DEF$1].concat(t?i:"<command>").join(" ")),this.single=t,this.curr=""}command(e,t,s={}){if(this.single)throw new Error('Disable "single" mode to add commands');let i=[],n=[],r=/(\[|<)/;if(e.split(/\s+/).forEach(e=>{(r.test(e.charAt(0))?n:i).push(e)}),(i=i.join(" "))in this.tree)throw new Error(`Command already exists: ${i}`);return i.includes("__")||n.unshift(i),n=n.join(" "),this.curr=i,s.default&&(this.default=i),this.tree[i]={usage:n,options:[],alias:{},default:{},examples:[]},t&&this.describe(t),this}describe(e){return this.tree[this.curr||DEF$1].describe=Array.isArray(e)?e:utils.sentences(e),this}option(e,t,s){let i=this.tree[this.curr||ALL$1],[n,r]=utils.parse(e);if(r&&r.length>1&&([n,r]=[r,n]),e=`--${n}`,r&&r.length>0){e=`-${r}, ${e}`;let t=i.alias[r];i.alias[r]=(t||[]).concat(n)}let o=[e,t||""];return void 0!==s?(o.push(s),i.default[n]=s):r||(i.default[n]=void 0),i.options.push(o),this}action(e){return this.tree[this.curr||DEF$1].handler=e,this}example(e){return this.tree[this.curr||DEF$1].examples.push(e),this}version(e){return this.ver=e,this}parse(e,t={}){let s,i,n,r=2,o=lib(e.slice(r),{alias:{h:"help",v:"version"}}),a=this.single,l=this.bin,c="";if(a)n=this.tree[DEF$1];else{let t=1,a=o._.length+1;for(;t<a;t++)s=o._.slice(0,t).join(" "),void 0!==this.tree[s]&&(c=s,r=t+2);if(i=void 0===(n=this.tree[c]))if(this.default)c=this.default,n=this.tree[c],e.unshift(c),r++;else if(s)return utils.error(l,`Invalid command: ${s}`)}if(o.help)return this.help(!a&&!i&&c);if(o.version)return this._version();if(!a&&void 0===n)return utils.error(l,"No command specified.");let d=this.tree[ALL$1];t.alias=Object.assign(d.alias,n.alias,t.alias),t.default=Object.assign(d.default,n.default,t.default);let u=lib(e.slice(r),t);if(!u||"string"==typeof u)return utils.error(l,u||"Parsed unknown option flag(s)!");let h=n.usage.split(/\s+/),p=h.filter(e=>"<"===e.charAt(0)),f=u._.splice(0,p.length);if(f.length<p.length)return c&&(l+=` ${c}`),utils.error(l,"Insufficient arguments!");h.filter(e=>"["===e.charAt(0)).forEach(e=>{f.push(u._.shift())}),f.push(u);let m=n.handler;return t.lazy?{args:f,name:c,handler:m}:m.apply(null,f)}help(e){console.log(utils.help(this.bin,this.tree,e||DEF$1,this.single))}_version(){console.log(`${this.bin}, ${this.ver}`)}}var lib$1=(e,t)=>new Sade(e,t);function stoppable(e){const t=new Map;let s=!1;return e.on("connection",e=>{t.set(e,0),e.once("close",()=>t.delete(e))}),e.on("request",(e,i)=>{const{socket:n}=e;t.set(n,t.get(n)+1),i.once("finish",()=>{const e=t.get(n)-1;t.set(n,e),s&&0===e&&n.end()})}),e.stop=i=>new Promise((n,r)=>{if(s)return n();s=!0;let o,a=!0;Array.from(t).map(([e,t])=>t||e.end()),e.close(e=>{if(e)return r(e);o&&clearTimeout(o),n(a)}),i&&(o=setTimeout(()=>{o=null,a=!1,Array.from(t.keys()).map(e=>e.end()),setImmediate(()=>Array.from(t.keys()).map(e=>e.destroy()))},i))}),e}function deserialize(e){return Array.isArray(e)?e.map(deserialize):null===e||"object"!=typeof e?e:"$$date$$"in e?new Date(e.$$date$$):"$$undefined$$"in e?void 0:Object.entries(e).reduce((e,[t,s])=>({...e,[t]:deserialize(s)}),{})}function serialize(e){return Array.isArray(e)?e.map(serialize):void 0===e?{$$undefined$$:!0}:e instanceof Date?{$$date$$:e.getTime()}:null===e||"object"!=typeof e?e:Object.entries(e).reduce((e,[t,s])=>({...e,[t]:serialize(s)}),{})}const priv=Symbol("jsrpc"),JSONRPC="2.0";class RpcServer extends EventEmitter{constructor(e){super();const{callTimeout:t,...s}=e,i=stoppable(http__default.createServer(handleRequest.bind(this)));Object.defineProperty(this,priv,{configurable:!0,value:{callTimeout:t,options:s,methods:{},server:i,started:!1}})}static create(e){return new RpcServer(e)}handle(e,t){return this[priv].methods[e]=t,this}start(){return new Promise((e,t)=>{const{started:s,server:i,options:n}=this[priv];if(s)return e(this);i.once("error",t),i.listen(n,s=>{if(s)return t(s);this[priv].started=!0,this.emit("start"),e(this)})})}get started(){return this[priv].started}get httpServer(){return this[priv].server}async stop(){this[priv].started&&(this[priv].started=!1,await this[priv].server.stop(5e3),this.emit("stop"))}}async function handleRequest(e,t){try{const{methods:s,callTimeout:i}=this[priv],n=await readBody(e),{id:r,jsonrpc:o,method:a,params:l}=n;if(o!==JSONRPC)throw new BadRequest(n);const c=s[a];if(!c)throw new MethodNotFound(n);if(!Array.isArray(l))throw new BadRequest(n);const d=deserialize(l);this.emit("call",{method:a,params:d});let u=Promise.resolve(c.apply(this,d));i&&(u=timeout(u,i));const h=serialize(await u);send(t,200,{jsonrpc:JSONRPC,result:h,id:r})}catch(e){const{name:s,message:i}=e,n=serialize({name:s,message:i,...e});send(t,e.status||500,{jsonrpc:JSONRPC,error:n,id:void 0})}}function send(e,t,s){s=JSON.stringify(s),e.writeHead(t,{"content-type":"application/json;charset=utf-8","content-length":Buffer.byteLength(s)}),e.end(s)}function readBody(e){return new Promise((t,s)=>{let i="";e.setEncoding("utf8"),e.on("error",s).on("data",e=>{i+=e}).on("end",()=>{try{t(JSON.parse(i))}catch(e){s(new BadRequest)}})})}function timeout(e,t){return new Promise((s,i)=>{const n=setTimeout(()=>i(new TimedOut),t);e.then(e=>{clearTimeout(n),s(e)},i)})}class CustomError extends Error{constructor(e,t){super(e),this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor),Object.assign(this,t)}}class MethodNotFound extends CustomError{constructor(e){super("Method not found",{status:404,body:e})}}class BadRequest extends CustomError{constructor(e){super("Bad request",{status:400,body:e})}}class TimedOut extends CustomError{constructor(e){super("Timed out",{status:504,body:e})}}const jsonrpc="2.0";class RpcClient{constructor(e){this.options=e}async call(e,...t){const s=JSON.stringify({jsonrpc:jsonrpc,method:e,params:serialize(t)}),i={...this.options,method:"POST",headers:{"Content-Type":"application/json;charset=utf-8","Content-Length":Buffer.byteLength(s),Connection:"keep-alive"}},n=await makeRequest(i,s),r=await readResponse(n);if(r.error){const e=new Error;throw Object.assign(e,deserialize(r.error)),e}return deserialize(r.result)}}function makeRequest(e,t){return new Promise((s,i)=>{const n=http.request(e,s);n.once("error",i),n.write(t),n.end()})}async function readResponse(e){e.setEncoding("utf8");let t="";for await(const s of e)t+=s;return JSON.parse(t)}function _interopDefault$1(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var fs=_interopDefault$1(fs$1);const resolved=Promise.resolve();class Queue{constructor(e=1){let t=0;const s=[],i=[];function n({fn:e,resolve:s,reject:i}){t++,resolved.then(()=>e()).then(s,i).then(r)}function r(){--t<e&&s.length&&n(s.shift()),0===t&&i.splice(0).map(e=>e())}Object.defineProperties(this,{running:{get:()=>t},pending:{get:()=>s.length}}),this.add=i=>new Promise((r,o)=>{const a={fn:i,resolve:r,reject:o};t<e?n(a):s.push(a)}),this.wait=()=>t?new Promise(e=>i.push(e)):resolved}}class DatastoreError extends Error{constructor(e){super(e),this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor)}}class KeyViolation extends DatastoreError{constructor(e,t){super("Key violation error"),this.fieldName=t,this.record=e}}class NotExists extends DatastoreError{constructor(e){super("Record does not exist"),this.record=e}}class NoIndex extends DatastoreError{constructor(e){super("No such index"),this.fieldName=e}}function delve(e,t){let s=0;for(t=t.split(".");e&&s<t.length;)e=e[t[s++]];return void 0===e||s<t.length?void 0:e}function getId(e,t){const s=hashString(stringify(e));for(let e=0;e<1e8;e++){const i=(s+e&2147483647).toString(36);if(!t.has(i))return i}throw new Error("Could not generate unique id")}function hashString(e){return Array.from(e).reduce((e,t)=>(e<<5)-e+t.charCodeAt(0)&4294967295,0)}function cleanObject(e){return Object.entries(e).reduce((e,[t,s])=>(void 0!==s&&(e[t]=s),e),{})}const DATE_SENTINEL="$jsdb$date$";function stringify(e){return JSON.stringify(e,(function(e,t){return this[e]instanceof Date?{[DATE_SENTINEL]:this[e].getTime()}:t}))}function parse$1(e){return JSON.parse(e,(function(e,t){return e===DATE_SENTINEL?new Date(t):"object"==typeof t&&DATE_SENTINEL in t?t[DATE_SENTINEL]:t}))}const readFile=util.promisify(fs.readFile),appendFile=util.promisify(fs.appendFile),openFile=util.promisify(fs.open),writeFile=util.promisify(fs.writeFile),syncFile=util.promisify(fs.fsync),closeFile=util.promisify(fs.close),renameFile=util.promisify(fs.rename);class Datastore{constructor(e){"string"==typeof e&&(e={filename:e}),this.options={serialize:stringify,deserialize:parse$1,special:{deleted:"$$deleted",addIndex:"$$addIndex",deleteIndex:"$$deleteIndex"},...e},this.loaded=!1,this._queue=new Queue,this._queue.add(()=>new Promise(e=>{this._starter=e})),this._empty(),e.autoload&&this.load(),e.autocompact&&this.setAutoCompaction(e.autocompact)}async load(){this.loaded||this.loading||(this.loading=!0,await this._hydrate(),await this._rewrite(),this.loaded=!0,this.loading=!1,this._starter())}reload(){return this._execute(()=>this._hydrate())}compact(e){return this._execute(()=>this._rewrite(e))}getAll(){return this._execute(()=>this._getAll())}async insert(e){return this._execute(async()=>(e=this._upsertDoc(e,{mustNotExist:!0}),await this._append(e),e))}async update(e){return this._execute(async()=>(e=this._upsertDoc(e,{mustExist:!0}),await this._append(e),e))}async upsert(e){return this._execute(async()=>(e=this._upsertDoc(e),await this._append(e),e))}async delete(e){const{deleted:t}=this.options.special;return this._execute(async()=>(e=this._deleteDoc(e),await this._append({[t]:e}),e))}async ensureIndex(e){const{fieldName:t}=e,{addIndex:s}=this.options.special;if(!this._indexes[t])return this._execute(()=>(this._addIndex(e),this._append({[s]:e})))}async deleteIndex(e){if("_id"===e)return;const{deleteIndex:t}=this.options.special;return this._execute(()=>(this._deleteIndex(e),this._append({[t]:{fieldName:e}})))}find(e,t){return this._execute(async()=>{if(!this._indexes[e])throw new NoIndex(e);return this._indexes[e].find(t)})}findOne(e,t){return this._execute(async()=>{if(!this._indexes[e])throw new NoIndex(e);return this._indexes[e].findOne(t)})}findAll(e){return this._execute(async()=>{if(!this._indexes[e])throw new NoIndex(e);return this._indexes[e].findAll()})}setAutoCompaction(e,t){this.stopAutoCompaction(),this.autoCompaction=setInterval(()=>this.compact(t),e)}stopAutoCompaction(){this.autoCompaction&&(clearInterval(this.autoCompaction),this.autoCompaction=void 0)}_execute(e){return this._queue.add(e)}_empty(){this._indexes={_id:Index.create({fieldName:"_id",unique:!0})}}async _hydrate(){const{filename:e,deserialize:t,special:{deleted:s,addIndex:i,deleteIndex:n}}=this.options,r=await readFile(e,{encoding:"utf8",flag:"a+"});this._empty();for(const e of r.split(/\n/).filter(Boolean)){const r=t(e);i in r?this._addIndex(r[i]):n in r?this._deleteIndex(r[n].fieldName):s in r?this._deleteDoc(r[s]):this._upsertDoc(r)}}_getAll(){return Array.from(this._indexes._id.data.values())}_addIndex(e){const{fieldName:t}=e,s=Index.create(e);this._getAll().forEach(e=>s.insertDoc(e)),this._indexes[t]=s}_deleteIndex(e){delete this._indexes[e]}_upsertDoc(e,{mustExist:t=!1,mustNotExist:s=!1}={}){const i=this._indexes._id.find(e._id);if(!i&&t)throw new NotExists(e);if(i&&s)throw new KeyViolation(e,"_id");if(null==(e=cleanObject(e))._id){const t=getId(e,this._indexes._id.data);e={_id:t,...e}}const n=Object.values(this._indexes);try{return n.forEach(t=>{i&&t.deleteDoc(i),t.insertDoc(e)}),e}catch(t){throw n.forEach(t=>{t.deleteDoc(e),i&&(t.deleteDoc(i),t.insertDoc(i))}),t}}_deleteDoc(e){const t=Object.values(this._indexes),s=this._indexes._id.find(e._id);if(!s)throw new NotExists(e);return t.forEach(e=>e.deleteDoc(s)),s}async _append(e){const{filename:t,serialize:s}=this.options,i=s(e)+"\n";await appendFile(t,i,"utf8")}async _rewrite({sorted:e=!1}={}){const{filename:t,serialize:s,special:{addIndex:i}}=this.options,n=t+"~",r=this._getAll();e&&r.sort((e,t)=>e._id<t._id?-1:1);const o=r.map(e=>s(e)+"\n"),a=Object.values(this._indexes).filter(e=>"_id"!==e.options.fieldName).map(e=>({[i]:e.options})).map(e=>s(e)+"\n");o.push(...a);const l=await openFile(n,"w");await writeFile(l,o.join(""),"utf8"),await syncFile(l),await closeFile(l),await renameFile(n,t)}}class Index{static create(e){return new(e.unique?UniqueIndex:Index)(e)}constructor(e){this.options=e,this.data=new Map}find(e){return this.data.get(e)||[]}findOne(e){const t=this.data.get(e);return t?t[0]:void 0}findAll(){return Array.from(this.data.entries())}addLink(e,t){let s=this.data.get(e);s||(s=[],this.data.set(e,s)),s.includes(t)||s.push(t)}removeLink(e,t){const s=this.data.get(e)||[],i=s.indexOf(t);-1!==i&&(s.splice(i,1),s.length||this.data.delete(e))}insertDoc(e){const t=delve(e,this.options.fieldName);null==t&&this.options.sparse||(Array.isArray(t)?t.forEach(t=>this.addLink(t,e)):this.addLink(t,e))}deleteDoc(e){const t=delve(e,this.options.fieldName);Array.isArray(t)?t.forEach(t=>this.removeLink(t,e)):this.removeLink(t,e)}}class UniqueIndex extends Index{find(e){return this.data.get(e)}findOne(e){return this.find(e)}addLink(e,t){if(this.data.has(e))throw new KeyViolation(t,this.options.fieldName);this.data.set(e,t)}removeLink(e,t){this.data.get(e)===t&&this.data.delete(e)}}Object.assign(Datastore,{KeyViolation:KeyViolation,NotExists:NotExists});var dist=Datastore;function portActive(e){return new Promise((t,s)=>{const i=setTimeout(()=>s(new Error("timed out connecting to server")),500),n=net.createConnection(e,()=>{clearTimeout(i),setImmediate(()=>{n.destroy(),t(!0)})});n.once("error",()=>{clearTimeout(i),t(!1)})})}function wrap(e){return(...t)=>Promise.resolve().then(()=>e(...t)).catch(e=>{console.error(e),process.exit(2)})}function getRoughTime(e){return e<=90?`${e} seconds`:(e=Math.round(e/60))<=90?`${e} minutes`:(e=Math.round(e/60))<=36?`${e} hours`:`${(e=Math.round(e/24)).toLocaleString()} days`}const jsdbMethods=new Set(["ensureIndex","deleteIndex","insert","update","upsert","delete","find","findOne","findAll","compact","reload"]);let tick;class JsdbServer extends RpcServer{constructor({files:e=".",idleTime:t=1800,...s}){super(s),e=path.resolve(e),Object.assign(this,{files:e,idleTime:t}),this.openDatabases=new Map,this.handle("shutdown",shutdown.bind(this)).handle("status",status.bind(this)).handle("dispatch",dispatch.bind(this)).handle("housekeep",housekeep.bind(this)).handle("clear",clear.bind(this)),setInterval(housekeep.bind(this),1e3*t).unref(),startClock()}}function startClock(){null==tick&&(tick=0,setInterval(()=>tick++,1e3).unref())}function shutdown(){setTimeout(()=>this.stop(5e3))}function status(){return{tick:tick,files:this.files,databases:Array.from(this.openDatabases.entries()).map(([e,{db:t,tick:s}])=>({name:e,tick:s}))}}function housekeep(){Array.from(this.openDatabases.entries()).forEach(([e,{tick:t,db:s}])=>{tick-t>this.idleTime&&this.openDatabases.delete(e)})}function clear(){this.openDatabases.clear()}async function dispatch(e,t,...s){if(!jsdbMethods.has(t))throw new Error(`Unknown method: ${t}`);let i;e=path.resolve(this.files,e);const n=this.openDatabases.get(e);return n?(n.tick=tick,i=n.db):(i=new dist(e),this.openDatabases.set(e,{db:i,tick:tick})),i.loaded||await i.load(),i[t](...s)}var version="2.0.1";const prog=lib$1("jsdbd"),DEFAULT_FILES=path.resolve(os.homedir(),".databases");async function startServer(e){let{files:t,idleTime:s,port:i,silent:n}=e;if(t=path.resolve(t),await portActive(i))return void(n||console.log(`Server already active on port ${i}`));const r=process.execPath,o=[...process.execArgv,process.argv[1],"__server","--port",i,"--files",t,"--idle-time",s];child_process.spawn(r,o,{stdio:"ignore",detached:!0}).unref(),n||console.log(`Serving databases in ${t} on port ${i}`)}function runServer(e){const{idleTime:t,files:s,port:i}=e,n=new JsdbServer({idleTime:t,files:s,port:i}),r=()=>n.stop(5e3);return process.on("SIGINT",r).on("SIGTERM",r),n.start()}async function showStatus({port:e}){const t=await sendCommand({port:e},"status");console.log(`jsdb server running on port ${e}\n`),console.log(`Uptime: ${getRoughTime(t.tick)}`),console.log(`Database files: ${t.files}\n`);const{databases:s}=t;if(s.length){console.log("Databases open:");for(const{name:e,tick:i}of s)console.log(`  ${e} (${getRoughTime(t.tick-i)})`)}else console.log("No databases open")}async function stopServer({port:e}){await sendCommand({port:e},"shutdown"),console.log(`Server on port ${e} shut down`)}async function clearServer({port:e}){await sendCommand({port:e},"clear"),console.log(`All databases cleared on port ${e}`)}async function sendCommand({port:e},t,...s){return await portActive(e)||(console.log(`No server active on port ${e}`),process.exit(1)),new RpcClient({port:e}).call(t,...s)}prog.version(version).option("--port, -p","The port to use",39720),prog.command("status","shows the status of the jsdbd daemon",{default:!0}).action(wrap(showStatus)),prog.command("start","starts the server").option("-f, --files","where files area stored",DEFAULT_FILES).option("-s, --silent","be quiet").option("--idle-time","cleaning interval",1800).action(wrap(startServer)),prog.command("clear","closes all databases").action(wrap(clearServer)),prog.command("stop","stops the server").action(wrap(stopServer)),prog.command("__server","runs the server (internal use)").action(wrap(runServer)),prog.parse(process.argv,{alias:{idleTime:"idle-time"}});
