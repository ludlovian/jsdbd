#!/usr/bin/env node
"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var http=_interopDefault(require("http")),https=_interopDefault(require("https")),fs$1=_interopDefault(require("fs")),util=_interopDefault(require("util")),path=require("path"),stoppable=(e,t)=>{t=void 0===t?1/0:t;const i=new Map;let s=!1,n=!0;return e instanceof https.Server?e.on("secureConnection",r):e.on("connection",r),e.on("request",(function(e,t){i.set(e.socket,i.get(e.socket)+1),t.once("finish",()=>{const t=i.get(e.socket)-1;i.set(e.socket,t),s&&0===t&&e.socket.end()})})),e.stop=function(r){setImmediate(()=>{s=!0,t<1/0&&setTimeout(a,t).unref(),e.close(e=>{r&&r(e,n)}),i.forEach(o)})},e._pendingSockets=i,e;function r(e){i.set(e,0),e.once("close",()=>i.delete(e))}function o(e,t){0===e&&t.end()}function a(){n=!1,i.forEach((e,t)=>t.end()),setImmediate(()=>{i.forEach((e,t)=>t.destroy())})}};function deserialize(e){return Array.isArray(e)?e.map(deserialize):null===e||"object"!=typeof e?e:"$$date$$"in e?new Date(e.$$date$$):"$$undefined$$"in e?void 0:Object.entries(e).reduce((e,[t,i])=>({...e,[t]:deserialize(i)}),{})}function serialize(e){return Array.isArray(e)?e.map(serialize):void 0===e?{$$undefined$$:!0}:e instanceof Date?{$$date$$:e.getTime()}:null===e||"object"!=typeof e?e:Object.entries(e).reduce((e,[t,i])=>({...e,[t]:serialize(i)}),{})}const jsonrpc="2.0";class RpcServer{constructor(e){const{callTimeout:t=1e4,idleTimeout:i=3e5,...s}=e;this.callTimeout=t,this.idleTimeout=i,this.options=s,this.methods={},this.server=stoppable(http.createServer((e,t)=>this._handle(e,t)),5e3),this._touch()}static create(e){return new RpcServer(e)}on(e,t){return this.methods[e]=t,this}async start(){return new Promise((e,t)=>{this.server.once("error",t),this.server.listen(this.options,i=>{if(i)return t(i);this.log("start"),e(this)})})}stop(){return new Promise((e,t)=>{this.idleTimeout=void 0,this._touch(),this.server.stop(i=>{if(i)return t(i);this.log("stop"),e(this)})})}log(){}_touch(){this._idleTimeout&&(clearTimeout(this._idleTimeout),this._idleTimeout=void 0),this.idleTimeout&&(this._idleTimeout=setTimeout(this.stop.bind(this),this.idleTimeout))}async _handle(e,t){let i;try{this._touch();const s=await readBody(e);if(i=s.id,s.jsonrpc!==jsonrpc)throw new BadRequest(s);const n=this.methods[s.method];if(!n)throw new MethodNotFound(s);if(!Array.isArray(s.params))throw new BadRequest(s);const r=deserialize(s.params);this.log("handle",s.method,...r);let o=Promise.resolve(n(...r));this.callTimeout&&(o=timeout(o,this.callTimeout));const a=serialize(await o);send(t,200,{jsonrpc:jsonrpc,result:a,id:i})}catch(e){const{name:s,message:n}=e,r=serialize({name:s,message:n,...e});send(t,e.status||500,{jsonrpc:jsonrpc,error:r,id:i})}}}function send(e,t,i){i=JSON.stringify(i),e.writeHead(t,{"content-type":"application/json;charset=utf-8","content-length":Buffer.byteLength(i)}),e.end(i)}function readBody(e){return new Promise((t,i)=>{let s="";e.setEncoding("utf8"),e.on("error",i).on("data",e=>{s+=e}).on("end",()=>{try{t(JSON.parse(s))}catch(e){i(new BadRequest)}})})}function timeout(e,t){return new Promise((i,s)=>{const n=setTimeout(()=>s(new TimedOut),t);e.then(e=>{clearTimeout(n),i(e)},s)})}class CustomError extends Error{constructor(e,t){super(e),this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor),Object.assign(this,t)}}class MethodNotFound extends CustomError{constructor(e){super("Method not found",{status:404,body:e})}}class BadRequest extends CustomError{constructor(e){super("Bad request",{status:400,body:e})}}class TimedOut extends CustomError{constructor(e){super("Timed out",{status:504,body:e})}}class Trigger{constructor(){let e,t;const i=new Promise((i,s)=>{e=i,t=s});return i.fire=e,i.cancel=t,i}static[Symbol.hasInstance](e){return e instanceof Promise&&"function"==typeof e.fire&&"function"==typeof e.cancel}}var dist=Object.freeze({__proto__:null,default:Trigger});function getCjsExportFromNamespace(e){return e&&e.default||e}var require$$0=getCjsExportFromNamespace(dist);function _interopDefault$1(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var Trigger$1=_interopDefault$1(require$$0);const priv=Symbol("priv");class PSwitch{constructor(e){Object.defineProperty(this,priv,{value:{value:e,triggers:new Map}}),getTrigger(this,e).fire()}set(e){const t=this[priv];e!==t.value&&(t.triggers.delete(t.value),t.value=e,getTrigger(this,e).fire())}when(e){return new Promise(t=>getTrigger(this,e).then(t))}get value(){return this[priv].value}}function getTrigger(e,t){const i=e[priv];let s=i.triggers.get(t);return s||(s=new Trigger$1,i.triggers.set(t,s),s)}class BinaryPSWitch extends PSwitch{constructor(e){super(Boolean(e))}set(e){super.set(Boolean(e))}when(e){return super.when(Boolean(e))}toggle(){this.set(!this.value)}get whenOn(){return this.when(!0)}get whenOff(){return this.when(!1)}}PSwitch.Binary=BinaryPSWitch;var dist$1=PSwitch;const priv$1=Symbol("priv"),resolved=Promise.resolve();class PLock{constructor(e=1){Object.defineProperty(this,priv$1,{value:{width:e,locks:0,waiting:[],busy:new dist$1(!1)}})}lock(e){const t=this[priv$1];return t.busy.set(!0),t.locks<t.width?(t.locks++,resolved):new Promise(i=>e?t.waiting.unshift(i):t.waiting.push(i))}release(){const e=this[priv$1];e.locks&&(e.waiting.length?e.waiting.shift()():0==--e.locks&&e.busy.set(!1))}get waiting(){return this[priv$1].waiting.length}get locks(){return this[priv$1].locks}whenIdle(){return this[priv$1].busy.when(!1)}whenBusy(){return this[priv$1].busy.when(!0)}async exec(e){try{return await this.lock(),await Promise.resolve(e())}finally{this.release()}}}var dist$2=Object.freeze({__proto__:null,default:PLock}),require$$1=getCjsExportFromNamespace(dist$2);function _interopDefault$2(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var fs=_interopDefault$2(fs$1),PLock$1=_interopDefault$2(require$$1);class DatastoreError extends Error{constructor(e){super(e),this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor)}}class KeyViolation extends DatastoreError{constructor(e,t){super("Key violation error"),this.fieldName=t,this.record=e}}class NotExists extends DatastoreError{constructor(e){super("Record does not exist"),this.record=e}}function delve(e,t){let i=0;for(t=t.split(".");e&&i<t.length;)e=e[t[i++]];return void 0===e||i<t.length?void 0:e}function getId(e,t){const i=hashString(stringify(e));for(let e=0;e<1e8;e++){const s=(i+e&2147483647).toString(36);if(!t.has(s))return s}throw new Error("Could not generate unique id")}function hashString(e){return Array.from(e).reduce((e,t)=>(e<<5)-e+t.charCodeAt(0)&4294967295,0)}function cleanObject(e){return Object.entries(e).reduce((e,[t,i])=>(void 0!==i&&(e[t]=i),e),{})}const DATE_SENTINEL="$jsdb$date$";function stringify(e){return JSON.stringify(e,(function(e,t){return this[e]instanceof Date?{[DATE_SENTINEL]:this[e].getTime()}:t}))}function parse(e){return JSON.parse(e,(function(e,t){return e===DATE_SENTINEL?new Date(t):"object"==typeof t&&DATE_SENTINEL in t?t[DATE_SENTINEL]:t}))}class Index{static create(e,t){return t.unique?new UniqueIndex(e,t):new Index(e,t)}constructor(e,t){this._execute=e._execute.bind(e),this.options=t,this._data=new Map}find(e){return this._execute(()=>this._data.get(e)||[])}findOne(e){return this._execute(()=>{const t=this._data.get(e);return t?t[0]:void 0})}getAll(){return this._execute(()=>Array.from(this._data.entries()))}_addLink(e,t){let i=this._data.get(e);i||(i=[],this._data.set(e,i)),i.includes(t)||i.push(t)}_removeLink(e,t){const i=this._data.get(e)||[],s=i.indexOf(t);-1!==s&&(i.splice(s,1),i.length||this._data.delete(e))}_insertDoc(e){const t=delve(e,this.options.fieldName);null==t&&this.options.sparse||(Array.isArray(t)?t.forEach(t=>this._addLink(t,e)):this._addLink(t,e))}_deleteDoc(e){const t=delve(e,this.options.fieldName);Array.isArray(t)?t.forEach(t=>this._removeLink(t,e)):this._removeLink(t,e)}}class UniqueIndex extends Index{find(e){return this.findOne(e)}findOne(e){return this._execute(()=>this._data.get(e))}_addLink(e,t){if(this._data.has(e))throw new KeyViolation(t,this.options.fieldName);this._data.set(e,t)}_removeLink(e,t){this._data.delete(e)}}const readFile=util.promisify(fs.readFile),appendFile=util.promisify(fs.appendFile),openFile=util.promisify(fs.open),writeFile=util.promisify(fs.writeFile),syncFile=util.promisify(fs.fsync),closeFile=util.promisify(fs.close),renameFile=util.promisify(fs.rename);class Datastore{constructor(e){"string"==typeof e&&(e={filename:e}),this.options={serialize:stringify,deserialize:parse,special:{deleted:"$$deleted",addIndex:"$$addIndex",deleteIndex:"$$deleteIndex"},...e},this.loaded=!1,this._lock=new PLock$1,this._lock.lock(),this._empty(),e.autoload&&this.load(),e.autocompact&&this.setAutoCompaction(e.autocompact)}async load(){return this._loaded?this._loaded:(this._loaded=this._hydrate().then(()=>this._lock.release()).then(()=>this.compact()).then(()=>{this.loaded=!0}),this._loaded)}reload(){return this._execute(()=>this._hydrate())}compact(){return this._execute(()=>this._rewrite())}getAll(){return this._execute(()=>this._getAll())}async insert(e){return this._execute(async()=>(e=this._upsertDoc(e,{mustNotExist:!0}),await this._append(e),e))}async update(e){return this._execute(async()=>(e=this._upsertDoc(e,{mustExist:!0}),await this._append(e),e))}async delete(e){const{deleted:t}=this.options.special;return this._execute(async()=>(e=this._deleteDoc(e),await this._append({[t]:e}),e))}async ensureIndex(e){const{fieldName:t}=e,{addIndex:i}=this.options.special;if(!this.indexes[t])return this._execute(()=>(this._addIndex(e),this._append({[i]:e})))}async deleteIndex(e){if("_id"===e)return;const{deleteIndex:t}=this.options.special;return this._execute(()=>(this._deleteIndex(e),this._append({[t]:{fieldName:e}})))}setAutoCompaction(e){this.stopAutoCompaction(),this.autoCompaction=setInterval(()=>this.compact(),e)}stopAutoCompaction(){this.autoCompaction&&(clearInterval(this.autoCompaction),this.autoCompaction=void 0)}_execute(e){return this._lock.exec(e)}_empty(){this.indexes={_id:Index.create(this,{fieldName:"_id",unique:!0})}}async _hydrate(){const{filename:e,deserialize:t,special:{deleted:i,addIndex:s,deleteIndex:n}}=this.options,r=await readFile(e,{encoding:"utf8",flag:"a+"});this._empty();for(const e of r.split(/\n/).filter(Boolean)){const r=t(e);s in r?this._addIndex(r[s]):n in r?this._deleteIndex(r[n].fieldName):i in r?this._deleteDoc(r[i]):this._upsertDoc(r)}}_getAll(){return Array.from(this.indexes._id._data.values())}_addIndex(e){const{fieldName:t}=e,i=Index.create(this,e);this._getAll().forEach(e=>i._insertDoc(e)),this.indexes[t]=i}_deleteIndex(e){delete this.indexes[e]}_upsertDoc(e,{mustExist:t=!1,mustNotExist:i=!1}={}){const s=this.indexes._id._data.get(e._id);if(!s&&t)throw new NotExists(e);if(s&&i)throw new KeyViolation(e,"_id");if(null==(e=cleanObject(e))._id){const t=getId(e,this.indexes._id._data);e={_id:t,...e}}const n=Object.values(this.indexes);try{return n.forEach(t=>{s&&t._deleteDoc(s),t._insertDoc(e)}),e}catch(t){throw n.forEach(t=>{t._deleteDoc(e),s&&(t._deleteDoc(s),t._insertDoc(s))}),t}}_deleteDoc(e){const t=Object.values(this.indexes),i=this.indexes._id._data.get(e._id);if(!i)throw new NotExists(e);return t.forEach(e=>e._deleteDoc(i)),i}async _append(e){const{filename:t,serialize:i}=this.options,s=i(e)+"\n";await appendFile(t,s,"utf8")}async _rewrite(e){const{filename:t,serialize:i,special:{addIndex:s}}=this.options,n=t+"~",r=Array.from(this._getAll()).map(e=>i(e)+"\n"),o=Object.values(this.indexes).filter(e=>"_id"!==e.options.fieldName).map(e=>({[s]:e.options})).map(e=>i(e)+"\n");r.push(...o);const a=await openFile(n,"w");await writeFile(a,r.join(""),"utf8"),await syncFile(a),await closeFile(a),await renameFile(n,t)}}Object.assign(Datastore,{KeyViolation:KeyViolation,NotExists:NotExists});var dist$3=Datastore;class JsdbServer extends RpcServer{constructor(e){super(e),this._basePath=e.base,this._dbs=new Map;for(const e of METHODS)this.on(e,this[e].bind(this));e.log&&(this.log=console.log.bind(console))}async connect(e){"string"==typeof e&&(e={filename:e});const{filename:t}=e;if(!this._dbs.has(t)){e.filename=path.resolve(this._basePath||"",e.filename);const i=new dist$3(e);await i.load(),this._dbs.set(t,i)}const i=this.db(t);return Object.values(i.indexes).map(e=>e.options)}reloadAll(){return this.log("reload"),Promise.all(Array.from(this._dbs.values()).map(e=>e.reload()))}stopServer(){setTimeout(()=>this.stop())}db(e){const t=this._dbs.get(e);if(!t)throw new Error(`Not connected to database at: ${e}`);return t}async getAll(e){return this.db(e).getAll()}async insert(e,t){return this.db(e).insert(t)}async update(e,t){return this.db(e).update(t)}async delete(e,t){return this.db(e).delete(t)}async ensureIndex(e,t){return this.db(e).ensureIndex(t)}async deleteIndex(e,t){return this.db(e).deleteIndex(t)}async compact(e){return this.db(e).compact()}async setAutoCompaction(e,t){return this.db(e).setAutoCompaction(t)}async stopAutoCompaction(e){return this.db(e).stopAutoCompaction()}async indexFind(e,t,i){return this.db(e).indexes[t].find(i)}async indexFindOne(e,t,i){return this.db(e).indexes[t].findOne(i)}async indexGetAll(e,t){return this.db(e).indexes[t].getAll()}}const METHODS=["connect","reloadAll","stopServer","getAll","insert","update","delete","ensureIndex","deleteIndex","compact","setAutoCompaction","stopAutoCompaction","indexFind","indexFindOne","indexGetAll"];function toArr(e){return null==e?[]:Array.isArray(e)?e:[e]}function toVal(e,t,i,s){var n,r=e[t],o=~s.string.indexOf(t)?null==i||!0===i?"":String(i):"boolean"==typeof i?i:~s.boolean.indexOf(t)?"false"!==i&&("true"===i||(e._.push(0*(n=+i)==0?n:i),!!i)):0*(n=+i)==0?n:i;e[t]=null==r?o:Array.isArray(r)?r.concat(o):[r,o]}var lib=function(e,t){t=t||{};var i,s,n,r,o,a={_:[]},c=0,d=0,l=0,u=(e=e||[]).length;const h=void 0!==t.alias,p=void 0!==t.unknown,f=void 0!==t.default;if(t.alias=t.alias||{},t.string=toArr(t.string),t.boolean=toArr(t.boolean),h)for(i in t.alias)for(s=t.alias[i]=toArr(t.alias[i]),c=0;c<s.length;c++)(t.alias[s[c]]=s.concat(i)).splice(c,1);if(t.boolean.forEach(e=>{t.boolean=t.boolean.concat(t.alias[e]=t.alias[e]||[])}),t.string.forEach(e=>{t.string=t.string.concat(t.alias[e]=t.alias[e]||[])}),f)for(i in t.default)t.alias[i]=t.alias[i]||[],(t[typeof t.default[i]]||[]).push(i);const m=p?Object.keys(t.alias):[];for(c=0;c<u;c++){if("--"===(n=e[c])){a._=a._.concat(e.slice(++c));break}for(d=0;d<n.length&&45===n.charCodeAt(d);d++);if(0===d)a._.push(n);else if("no-"===n.substring(d,d+3)){if(r=n.substring(d+3),p&&!~m.indexOf(r))return t.unknown(n);a[r]=!1}else{for(l=d+1;l<n.length&&61!==n.charCodeAt(l);l++);for(r=n.substring(d,l),o=n.substring(++l)||c+1===u||45===(""+e[c+1]).charCodeAt(0)||e[++c],s=2===d?[r]:r,l=0;l<s.length;l++){if(r=s[l],p&&!~m.indexOf(r))return t.unknown("-".repeat(d)+r);toVal(a,r,l+1<s.length||o,t)}}}if(f)for(i in t.default)void 0===a[i]&&(a[i]=t.default[i]);if(h)for(i in a)for(s=t.alias[i]||[];s.length>0;)a[s.shift()]=a[i];return a},version="1.2.1";function main(){const e=readOptions();if(e.help)return showHelp();const t=new JsdbServer(e),i=t.stop.bind(t),s=t.reloadAll.bind(t);return process.on("SIGTERM",i).on("SIGINT",i),process.on("SIGUSR1",s),t.start()}function readOptions(){const e=lib(process.argv.slice(2),{alias:{h:"help",t:"timeout",p:"port",l:"log",b:"base"}});return{idleTimeout:e.timeout,port:e.port,log:!!e.log,base:e.base,help:e.help}}function showHelp(){console.log(`jsdbd v${version}\n\n`+"Runs a jsdb daemon. Options:\n-t --timeout <ms>  Set the idle timeout (in ms) for the daemon to exit\n-p --port <n>      Set the port to listen on\n-b --base <dir>    Sets the base dir for database files\n-l --log           Turns on logging of calls to stdout\n")}main();
