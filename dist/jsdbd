#!/usr/bin/env node
'use strict';

var path = require('path');
var os = require('os');
var child_process = require('child_process');
var ms = require('ms');
var sade = require('sade');
var jsrpc = require('jsrpc');
var Database = require('jsdb');
var net = require('net');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var ms__default = /*#__PURE__*/_interopDefaultLegacy(ms);
var sade__default = /*#__PURE__*/_interopDefaultLegacy(sade);
var Database__default = /*#__PURE__*/_interopDefaultLegacy(Database);

function portActive (port) {
  return new Promise((resolve, reject) => {
    const tm = setTimeout(
      () => reject(new Error('timed out connecting to server')),
      500
    );
    const conn = net.createConnection(port, () => {
      clearTimeout(tm);
      setImmediate(() => {
        conn.destroy();
        resolve(true);
      });
    });
    conn.once('error', () => {
      clearTimeout(tm);
      resolve(false);
    });
  })
}
function wrap (fn) {
  return (...args) =>
    Promise.resolve()
      .then(() => fn(...args))
      .catch(err => {
        console.error(err);
        process.exit(2);
      })
}
const jsdbMethods = new Set([
  'ensureIndex',
  'deleteIndex',
  'insert',
  'update',
  'upsert',
  'delete',
  'find',
  'findOne',
  'getAll',
  'compact',
  'reload'
]);

class JsdbServer extends jsrpc.RpcServer {
  constructor ({ files = '.', idleTime = '30m', ...options }) {
    super(options);
    files = path.resolve(files);
    idleTime = ms__default['default'](idleTime + '');
    const startTime = Date.now();
    Object.assign(this, { files, idleTime, startTime });
    this.openDatabases = new Map();
    this.handle('shutdown', shutdown.bind(this))
      .handle('status', status.bind(this))
      .handle('dispatch', dispatch.bind(this))
      .handle('housekeep', housekeep.bind(this))
      .handle('clear', clear.bind(this));
    setInterval(housekeep.bind(this), idleTime).unref();
  }
}
function shutdown () {
  setTimeout(() => this.stop(5000));
}
function status () {
  const now = Date.now();
  return {
    uptime: now - this.startTime,
    idleTime: this.idleTime,
    files: this.files,
    databases: Array.from(this.openDatabases.entries()).map(
      ([name, { db, lastTouch }]) => ({ name, uptime: now - lastTouch })
    )
  }
}
function housekeep () {
  const now = Date.now();
  Array.from(this.openDatabases.entries()).forEach(
    ([filename, { lastTouch }]) => {
      if (now - lastTouch > this.idleTime) {
        this.openDatabases.delete(filename);
      }
    }
  );
}
function clear () {
  this.openDatabases.clear();
}
async function dispatch (filename, method, ...args) {
  if (!jsdbMethods.has(method)) {
    throw new Error(`Unknown method: ${method}`)
  }
  filename = path.resolve(this.files, filename);
  const lastTouch = Date.now();
  let db;
  const rec = this.openDatabases.get(filename);
  if (rec) {
    rec.lastTouch = lastTouch;
    db = rec.db;
  } else {
    db = new Database__default['default'](filename);
    this.openDatabases.set(filename, { db, lastTouch });
  }
  if (!db.loaded) await db.load();
  return db[method](...args)
}

var version = "2.3.2";

const prog = sade__default['default']('jsdbd');
const DEFAULT_FILES = path.resolve(os.homedir(), '.databases');
prog.version(version).option('--port, -p', 'The port to use', 39720);
prog
  .command('status', 'shows the status of the jsdbd daemon', { default: true })
  .action(wrap(showStatus));
prog
  .command('start', 'starts the server')
  .option('-f, --files', 'where files area stored', DEFAULT_FILES)
  .option('-s, --silent', 'be quiet')
  .option('--idle-time', 'cleaning interval', '30m')
  .action(wrap(startServer));
prog.command('clear', 'closes all databases').action(wrap(clearServer));
prog.command('stop', 'stops the server').action(wrap(stopServer));
prog
  .command('__server', 'runs the server (internal use)')
  .action(wrap(runServer));
prog.parse(process.argv, {
  alias: {
    idleTime: 'idle-time'
  }
});
async function startServer (opts) {
  let { files, idleTime, port, silent } = opts;
  files = path.resolve(files);
  if (await portActive(port)) {
    if (!silent) console.log(`Server already active on port ${port}`);
    return
  }
  const cmd = process.execPath;
  const args = [
    ...process.execArgv,
    process.argv[1],
    '__server',
    '--port',
    port,
    '--files',
    files,
    '--idle-time',
    idleTime
  ];
  const spawnOpts = {
    stdio: 'ignore',
    detached: true
  };
  child_process.spawn(cmd, args, spawnOpts).unref();
  if (!silent) console.log(`Serving databases in ${files} on port ${port}`);
}
function runServer (opts) {
  const { idleTime, files, port } = opts;
  const server = new JsdbServer({ idleTime, files, port });
  const shutdown = () => server.stop();
  process.on('SIGINT', shutdown).on('SIGTERM', shutdown);
  return server.start()
}
async function showStatus ({ port }) {
  const status = await sendCommand({ port }, 'status');
  console.log(`jsdb server running on port ${port}\n`);
  console.log(`Uptime: ${ms__default['default'](status.uptime, { long: true })}`);
  console.log(`Housekeep every ${ms__default['default'](status.idleTime)}`);
  console.log(`Database files: ${status.files}\n`);
  const { databases } = status;
  if (!databases.length) {
    console.log('No databases open');
    return
  }
  console.log('Databases open:');
  for (const { name, uptime } of databases) {
    console.log(`  ${name} (${ms__default['default'](uptime, { long: true })})`);
  }
}
async function stopServer ({ port }) {
  await sendCommand({ port }, 'shutdown');
  console.log(`Server on port ${port} shut down`);
}
async function clearServer ({ port }) {
  await sendCommand({ port }, 'clear');
  console.log(`All databases cleared on port ${port}`);
}
async function sendCommand ({ port }, method, ...args) {
  if (!(await portActive(port))) {
    console.log(`No server active on port ${port}`);
    process.exit(1);
  }
  const client = new jsrpc.RpcClient({ port });
  return client.call(method, ...args)
}
